/*-
 * Copyright (C) 2014-2015 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.catacombae.hfs.types.decmpfs;

import java.io.PrintStream;
import java.math.BigInteger;

import org.catacombae.csjc.PrintableStruct;
import org.catacombae.util.Util;


/**
 * This class was generated by CStructToJavaClass.
 *
 * @author <a href="https://catacombae.org" target="_top">Erik Larsson</a>
 */
public class DecmpfsHeader implements PrintableStruct {
    /*
     * struct DecmpfsHeader
     * size: 16 bytes
     * description:
     *
     * BP  Size  Type  Identifier       Description
     * --------------------------------------------
     * 0   4     le32  magic
     * 4   4     le32  compressionType
     * 8   8     le64  fileSize
     */

    /** Proper value for 'magic' (this is "cmpf" in ASCII). */
    public static final long MAGIC = 0x636D7066L;

    public static final int COMPRESSION_TYPE_INLINE = 3;
    public static final int COMPRESSION_TYPE_RESOURCE = 4;

    public static final int STRUCTSIZE = 16;

    private final int magic;
    private final int compressionType;
    private final long fileSize;

    public DecmpfsHeader(byte[] data, int offset) {
        this.magic = Util.readIntBE(data, offset + 0);
        this.compressionType = Util.readIntBE(data, offset + 4);
        this.fileSize = Util.readLongBE(data, offset + 8);
    }

    public static int length() {
        return STRUCTSIZE;
    }

    /** */
    public final long getMagic() {
        return Util.unsign(getRawMagic());
    }

    /** */
    public final long getCompressionType() {
        return Util.unsign(getRawCompressionType());
    }

    /** */
    public final BigInteger getFileSize() {
        return Util.unsign(getRawFileSize());
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawMagic() {
        return Util.byteSwap(this.magic);
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawCompressionType() {
        return Util.byteSwap(this.compressionType);
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final long getRawFileSize() {
        return Util.byteSwap(this.fileSize);
    }

    @Override
    public void printFields(PrintStream ps, String prefix) {
        ps.println(prefix + " magic: " + getMagic());
        ps.println(prefix + " compressionType: " + getCompressionType());
        ps.println(prefix + " fileSize: " + getFileSize());
    }

    @Override
    public void print(PrintStream ps, String prefix) {
        ps.println(prefix + "DecmpfsHeader:");
        printFields(ps, prefix);
    }

    public byte[] getBytes() {
        byte[] result = new byte[length()];
        getBytes(result, 0);
        return result;
    }

    public int getBytes(byte[] result, int offset) {
        int startOffset = offset;

        Util.arrayPutBE(result, offset, this.magic);
        offset += 4;
        Util.arrayPutBE(result, offset, this.compressionType);
        offset += 4;
        Util.arrayPutBE(result, offset, this.fileSize);
        offset += 8;

        return offset - startOffset;
    }
}
